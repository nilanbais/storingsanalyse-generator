"""
This script is for the development of the functions to use on the metadata.
Building some sort of layer on top op the standardized lay-out of the metadata makes working with the data in
a Jupyter Notebook easier and more organized.

The functions are written for a json metadata file generated by the metadata_file builder
{
    project: projectnaam,
    start_datum: dd-mm-yyy,
    contract_info: {
        tijdsregistratie: True,
        ...
    },
    meldingen: {
        f"{maand}_{jaar}": {
            DI_num: aantal meldingen,
            DI_num: aantal meldingen
        }
        f"{maand}_{jaar}": {
            ...
        }
    },
    storingen: {
        f"{maand}_{jaar}": {
            DI_num: aantal storingen,
            DI_num: aantal storingen
        }
        f"{maand}_{jaar}": {
            ...
        }
    }
}


Fucnties/Modules die geschreven moeten worden, zijn:
    -   [x] het opvragen van het gemiddelde aantal meldingen per maand, per jaar
    -   [x] het opvragen van het aantal meldingen in een gegeven maand, een gegeven jaar
    -   [x] module voor het filteren van meldingen of storingen op een te kiezen di nummer
    -   [ ] module voor het updaten en opslaan van de nieuw gegenereerde metadata
"""
import json
import pandas as pd
import numpy as np

from typing import Union, List, Dict
# Todo: ONDERSTAANDE AANPASSING STERK OVERWEGEN
"""
Aanpassing:
Wanneer de bovenstaande objectstructuur voor meer dan alleen een storingsanalyse wordt toegepast, is het misschien
beter om een splitsing te maken. een dergelijke splitsing zal dan gemaakt moeten worden tussen de metadata
objectstructuur met de modules die een abstracte bewerking doen op de data (count_values & sum_values) en de bewerkingen
die een type specifieke bewerking doen (alles met storingsanalyse specifieke handelingen).
"""
# Todo: class uitbreiden met de isolatie van de mogelijke di nummers die worden gebruikt in het project


# todo: documentatie aanpassen
class MetadataStoringsAnalyse:

    _filepath_dict = {"Coentunnel-tracé": "metadata_file_coentunnel-tracé.json",
                      "Sluis Eefde": "metadata_file_sluis_eefde.json"}

    _quarters = {'Q1': ['01', '02', '03'],
                 'Q2': ['04', '05', '06'],
                 'Q3': ['07', '08', '09'],
                 'Q4': ['10', '11', '12']}

    def __init__(self, project):
        self.filepath = self._get_filepath(project=project)

        self.tijdsregistratie = self.contract_info()["tijdsregistratie"]  # true or false

    def _get_filepath(self, project):
        _filename = [MetadataStoringsAnalyse._filepath_dict[key]
                     for key in MetadataStoringsAnalyse._filepath_dict.keys()
                     if project.lower() in key.lower()]

        if len(_filename) > 1:
            raise ValueError(f"Found too many files using the given project {project}. \nResults: {_filename} ")

        self.filename = _filename[0]

        rel_filepath = "..\\metadata\\" + self.filename
        return rel_filepath

    def _read_json(self):
        with open(self.filepath, 'r') as json_file:
            _data = json.load(json_file)
        return _data

    def get_all_data(self):
        data = pd.json_normalize(data=self._read_json(), max_level=0)
        return data

    def project(self):
        meta = self.get_all_data()
        return meta["project"][0]

    def startdate(self):
        meta = self.get_all_data()
        return meta["start_datum"][0].replace('_', '-')

    def contract_info(self):
        meta = self.get_all_data()
        return meta["contract_info"][0]

    def meldingen(self):
        meta = self.get_all_data()
        return meta["meldingen"][0]

    def storingen(self):
        meta = self.get_all_data()
        return meta["storingen"][0]

    # todo: toevoegen aan documentatie + de aanpassing in de objectstructuur van de metadata documenteren
    def poo_data(self):
        meta = self.get_all_data()
        return meta["poo_codes"][0]

    def get_di_dict(self, di: str, notification_type: str = 'meldingen') -> dict:
        """
        Module to filter the dict provided by self.meldingen() or self.storingen() on a specific di number.
        :param notification_type: specification which of the two dict to use. dtype=string
        :param di: number of the deelinstallatie (subsystem). dtype=int or string
        :return: filtered dictionary
        """
        dictionary = self.meldingen() if str(notification_type).lower() in ['m', 'melding', 'meldingen'] \
            else self.storingen() if str(notification_type.lower()) in ['s', 'storing', 'storingen'] \
            else False

        if not dictionary:
            raise ValueError(f"Incorrect input value given: {notification_type}. Please choose one of the following notification types: 'meldingen', 'storingen'.")

        di_set = {di}  # {di} makes a set of di. set(di) gave different result

        result_dict = {date_key: dictionary[date_key][sub_system]
                       for date_key in dictionary.keys()
                       for sub_system in dictionary[date_key].keys() if sub_system in di_set}

        if result_dict == {}:
            print(f"Can't find sub_system '{di_set}' in the metadata.")

        return result_dict

    @staticmethod
    def _check_first_element(dictionary: dict or list) -> list or np.nan:
        if isinstance(dictionary, dict):
            first_element = [dictionary[key] for key in dictionary.keys()][0]
        elif isinstance(dictionary, list):
            first_element = [dictionary[key] for key in range(len(dictionary))]
        else:
            first_element = np.nan

        return first_element

    def _sum_all_values(self, dictionary: dict) -> int or float:
        """
        Takes a dictionary and sums up all the values found in the dictionary.
        If given a dictionary of dictionaries, it will return the sum of all the values of the underlying
        dictionaries.
        :param dictionary:
        :return:
        """
        first_element = self._check_first_element(dictionary=dictionary)
        if isinstance(first_element, dict):
            return sum([self._sum_all_values(dictionary[key]) for key in dictionary.keys()])

        return sum(dictionary.values())

    def sum_values(self, dictionary: dict, keys: list = None):
        """

        Gedrag nu voor het recursive deel is dat het één getal als antwoord geeft. Misschien is het voor het gebruik
        van de module beter om te stoppen op het hoogste level van keys (stap voordat één antwoord verkregen wordt.
        Dit kan ook een extra feature worden door het optioneel veranderen van een extra parameter.
        :param dictionary:
        :param keys:
        :return:
        """
        if keys is None:
            return self._sum_all_values(dictionary)

        first_element = self._check_first_element(dictionary=dictionary)

        # if first element is int while keys are given
        if isinstance(first_element, int):
            dictionary = {key: dictionary[key] for key in keys}
            return sum([self._sum_all_values(dictionary)])

        # return sum of specific keys from dict
        return sum([self._sum_all_values(dictionary[key]) for key in dictionary.keys() if key in keys])

    def _count_all_values(self, dictionary: dict):
        """
        Takes a dictionary and counts the number of keys found in the dictionary.
        If given a dictionary of dictionaries, it will return number of keys found in the top layer of the
        dictionary.
        :param dictionary:
        :return:
        """
        first_element = self._check_first_element(dictionary=dictionary)

        if isinstance(first_element, dict):
            return len([self._count_all_values(dictionary[key]) for key in dictionary.keys()])

        return len([dictionary[key] for key in dictionary.keys()])

    def count_values(self, dictionary: dict, keys=None):
        if keys is None:
            return self._count_all_values(dictionary)
        # check if keys is a list. If not, change it to list
        keys = [k for k in keys] if not isinstance(keys, list) else keys
        # return sum of specific keys from dict
        return len([self._count_all_values(dictionary[key]) for key in dictionary.keys() if key in keys])

    def avg_monthly(self, dictionary: dict, exclude_keys=None):
        summed_values = self.sum_values(dictionary=dictionary, keys=exclude_keys)
        counted = self.count_values(dictionary=dictionary, keys=exclude_keys)
        return summed_values / counted

    @staticmethod
    def _sort_keys_by_year(dictionary: dict, exclude_year: Union[List[str], str] = None) -> dict:
        """
        Sorts the keys of the given dictionary by years. It returns a new dictionary with setup
        {year: [keys containing year]}
        :param dictionary:
        :param exclude_year:
        :return: dict with build {year: [keys containing year]}
        """
        result_dict = {}
        for datum in dictionary.keys():
            jaar = datum.split('_')[-1]
            if (exclude_year is not None) and jaar in (exclude_year if isinstance(exclude_year, list) else [exclude_year]):
                continue
            else:
                if jaar in result_dict:
                    result_dict[jaar].append(datum)
                else:
                    result_dict[jaar] = [datum]
        return result_dict

    # todo: Onderstaande heeft hetzelfde resultaat als hierboven echter is input dtype anders
    @staticmethod
    def order_month_list_by_year(month_list: list) -> dict:
        """
        Takes a month_list (result from self.get_month_list()) and orders it by year
        :param month_list:
        :return:
        """
        month_list_ordered_by_year = {}

        for month_year in month_list:
            year = month_year.split('_')[-1]
            if year not in month_list_ordered_by_year:
                month_list_ordered_by_year[year] = [month_year]
            else:
                month_list_ordered_by_year[year].append(month_year)

        return month_list_ordered_by_year

    def avg_yearly(self, dictionary: dict, exclude_year: Union[List[str], str] = None) -> float:
        """
        Module calulates the yearly average number of notifications.
        :param dictionary:
        :param exclude_year:
        :return:
        """
        sorted_keys = self._sort_keys_by_year(dictionary=dictionary, exclude_year=exclude_year)
        # Bellow gives a list like [avg_year_1, avg_year_2, ... , avg_year_n]
        notifications_per_year = [self.sum_values(dictionary=dictionary, keys=sorted_keys[year]) for year in sorted_keys.keys()]
        if len(notifications_per_year) == 0:
            return int(0)

        return sum(notifications_per_year) / len(notifications_per_year)

    def _sort_keys_by_quarters(self, dictionary: dict):
        """

        :param dictionary:
        :return:
        """
        result_dict = dict()
        for date in dictionary.keys():
            month, year = date.split('_')
            for quarter in self._quarters.keys():
                key = f'{quarter}_{year}'
                if month in self._quarters[quarter]:
                    if key in result_dict:
                        result_dict[key].append(date)
                    else:
                        result_dict[key] = [date]

        return result_dict

    # todo: documenteren
    def avg_quarterly(self, dictionary: dict, exclude_quarter: Union[List[str], str] = None) -> float:
        # sort dict per quarter
        # notifications_per_quarter like: [q1_year_1, q2_year_1, ..., q4_year_n]
        # return sum() / len()
        sorted_keys = self._sort_keys_by_quarters(dictionary=dictionary)
        # Bellow gives a list like [avg_q_year_1, avg_q2_year_1, ... , avg_q4_year_n]
        notifications_per_q = [self.sum_values(dictionary=dictionary, keys=sorted_keys[q]) for q in sorted_keys.keys()]  # ook te schrijven als keys=[val for val in sorted_keys.values()]
        if len(notifications_per_q) == 0:
            return int(0)
        return sum(notifications_per_q) / len(notifications_per_q)

    # todo: aanpassen in documentatie
    # todo: finctie omschrijven zodat het werkt via => 'geeft me resultaten van maart' of 'geeft alleen Q4' (van alle jaren)
    def get_month_list(self, notification_type: str = 'melding', exclude_month: Union[List[str], str] = None, exclude_quarter: Union[List[str], str] = None, exclude_year: Union[List[str], str] = None) -> list:
        """
        Returns the list of all the keys that do not contain the specified excluded month or year.
        :param notification_type: specification of the dictionary to get the keys from. default=self.meldingen()
        :param exclude_month: When parsing multiple values, parse them in a list. [excluded_month_1, ... ,excluded_month_n]
        :param exclude_year: same as exclude_month.
        :return:
        """
        dictionary = self.meldingen() if str(notification_type).lower() in ['m', 'melding', 'meldingen'] \
            else self.storingen() if str(notification_type.lower()) in ['s', 'storing', 'storingen'] \
            else False

        if not dictionary:
            raise ValueError(f"Incorrect input value given: {notification_type}. Please choose one of the following notification types: 'meldingen', 'storingen'.")

        _set_months = set(exclude_month) if exclude_month is not None else set()
        _set_years = set(exclude_year) if exclude_year is not None else set()
        _set_quarter = set(self._quarter_to_month_numbers(exclude_quarter)) if exclude_quarter is not None else set()

        return [key for key in dictionary.keys() if ((key.split('_')[0] not in (_set_months or _set_quarter)) and
                                                     key.split('_')[-1] not in _set_years)]

    def get_keys(self, dictionary: dict,  containing_months: Union[List[str], str] = None, containing_quarter: Union[List[str], str] = None, containing_year: Union[List[str], str] = None) -> list:
        """
        Returns a list of the different keys containing the months, months of a quarter, or the year specified.
        (Note that this module is the complete opposite of self.get_month_list().
        :param dictionary:
        :param containing_months:
        :param containing_quarter:
        :param containing_year:
        :return:
        """
        _set_months = set(containing_months) if containing_months is not None else set()
        _set_years = set(containing_year) if containing_year is not None else set()
        _set_quarter = set(self._quarter_to_month_numbers(containing_quarter)) if containing_quarter is not None else set()

        return [key for key in dictionary.keys() if ((key.split('_')[0] in (_set_months or _set_quarter)) and
                                                     key.split('_')[-1] in _set_years)]

    # todo: documenteren
    @staticmethod
    def filter_dictionary_keys(dictionary: dict, keys: List[str]) -> dict:
        """
        Sort of the same functionality as get_month_list, but instead of returning a list with the keynames it returns
        a filtered dictinary.
        :param dictionary:
        :param keys:
        :return:
        """
        keys_to_return = set(keys)
        result = {key: dictionary[key] for key in dictionary.keys() if key in keys_to_return}
        return result

    def _quarter_to_month_numbers(self, quarters: Union[List[str], str]) -> list:
        """
        Returns the corresponding months of the given quarters
        :param quarter:
        :return:
        """
        if isinstance(quarters, str):
            return self._quarters.__getitem__(quarters.capitalize())

        list_to_return = []
        nums = [val for key, val in self._quarters.items() for q in quarters if key == q.capitalize()]
        for n in nums:
            for num in n:
                list_to_return.append(num)

        return list_to_return

    @staticmethod
    def _order_frequency_table(freq_table: dict) -> dict:
        return {key: value for key, value in sorted(freq_table.items(), key=lambda item: item[1], reverse=True)}

    def make_ddict_frequency_table(self, dictionary: Dict[str, dict]) -> dict:
        freq_table = {}
        for ddict in dictionary.values():
            for key, value in ddict.items():
                if key in freq_table:
                    freq_table[key] += value
                else:
                    freq_table[key] = value
        return self._order_frequency_table(freq_table)

    def poo_avg_table(self, poo_dictionary: dict) -> dict:
        sum_per_code = self.make_ddict_frequency_table(dictionary=poo_dictionary)
        avg_table = {key: sum_per_code[key] / len(poo_dictionary) for key in sum_per_code.keys()}
        return self._order_frequency_table(avg_table)


if __name__ == '__main__':
    import os
    os.chdir('..\\rapport generator')

    project = 'coentunnel'
    metadata = MetadataStoringsAnalyse(project)

    meldingen = metadata.meldingen()
    storingen = metadata.storingen()

    m = metadata.sum_values(meldingen)
    s = metadata.sum_values(storingen)  # sum of all values found in the dicts of dicts

    data2019 = [key for key in storingen.keys() if '2019' in key]
    oktober = [key for key in meldingen.keys() if "10" in key[:3]]

    aantal_storingen_2019 = metadata.sum_values(dictionary=storingen, keys=data2019)  # 166
    aantal_meldingen_maart_2018 = metadata.sum_values(dictionary=meldingen, keys=['03_2018'])  # 27
    lijst_meldingen_oktober = [metadata.sum_values(dictionary=meldingen, keys=key) for key in oktober]

    meling_ = metadata.count_values(dictionary=meldingen, keys='03_2018')
    storingen_2019 = metadata.count_values(dictionary=storingen, keys=data2019)

    avg_oktober = metadata.avg_monthly(dictionary=meldingen, exclude_keys=oktober)
    avg_2019 = metadata.avg_monthly(dictionary=storingen, exclude_keys=data2019)

    data_61_mod = metadata.get_di_dict(notification_type='meldingen', di='61')

    avg_mod = metadata.avg_yearly(dictionary=meldingen, exclude_year=['2020'])

    maand_lijst = metadata.get_month_list(exclude_month=['02'], exclude_year=['2019'])

    meldingen_per_di_avg = metadata.avg_yearly(dictionary=metadata.get_di_dict(di='46A-08'), exclude_year='2020')

    months_to_exclude = [metadata._quarters[q][i] for q in metadata._quarters.keys() if q != 'Q1' for i in
                         range(len(metadata._quarters[q]))]
    month_list = metadata.get_month_list(exclude_month=months_to_exclude)

    kwartaal_lijst=['q1', 'q3']
    mmlijst = metadata._quarter_to_month_numbers(quarters=kwartaal_lijst)
    test_q_m_list = metadata.get_month_list(exclude_quarter='q3')
    sort_by_q = metadata._sort_keys_by_quarters(dictionary=metadata.meldingen())
    avg_q = metadata.avg_quarterly(dictionary=metadata.meldingen())

    poo = metadata.poo_data()['probleem']
    print([metadata.sum_values(dictionary=poo[_], keys=['P05']) for _ in poo.keys()])
