"""
This script is for the development of the functions to use on the metadata.
Building some sort of layer on top op the standardized lay-out of the metadata makes working with the data in
a Jupyter Notebook easier and more organized.

The functions are written for a json metadata file generated by the metadata_file builder
{
    project: projectnaam,
    start_datum: dd-mm-yyy,
    contract_info: {
        tijdsregistratie: True,
        ...
        aanwezige_deelinstallaties: [Lijst DI_nummers],
        POO_codes: [Lijst POO codes]
    },
    poo_codes: {
        probleem: {
            "{kwartaal}_{jaar}": {
                POO_code: aantal meldingen,
                POO_code: aantal meldingen,
            }
        },
        oorzaak: {
                [structuur als in probleem]
            }
        },
        oplossing: {
                [structuur als in probleem]
            }
        }
    },
    meldingen: {
        "{maand}_{jaar}": {
            DI_num: aantal meldingen,
            DI_num: aantal meldingen
        }
        "{maand}_{jaar}": {
            ...
        }
    },
    storingen: {
        "{maand}_{jaar}": {
            DI_num: aantal storingen,
            DI_num: aantal storingen
        }
        "{maand}_{jaar}": {
            ...
        }
    }
}


Functies/Modules die geschreven moeten worden, zijn:
    -   [x] het opvragen van het gemiddelde aantal meldingen per maand, per jaar
    -   [x] het opvragen van het aantal meldingen in een gegeven maand, een gegeven jaar
    -   [x] module voor het filteren van meldingen of storingen op een te kiezen di nummer
    -   [ ] module voor het updaten en opslaan van de nieuw gegenereerde metadata
"""
import json
import pandas as pd
import numpy as np

from typing import Union, List, Dict
from pandas import DataFrame


# todo: documentatie aanpassen
# todo: in documetatie ergens expliciet vermelden waar ntype voor staat
class MetadataStoringsAnalyse:

    # todo: filepath dict verplaatsen naar map resources\\information_mapping
    _filepath_dict = {"Coentunnel-tracé": "metadata_file_coentunnel-tracé.json",
                      "Sluis Eefde": "metadata_file_sluis_eefde.json"}

    _quarters = {'Q1': ['01', '02', '03'],
                 'Q2': ['04', '05', '06'],
                 'Q3': ['07', '08', '09'],
                 'Q4': ['10', '11', '12']}

    def __init__(self, project):
        self.filepath = self._get_filepath(project=project)

        self.tijdsregistratie = self.contract_info()["tijdsregistratie"]  # true or false
        self._quarter = None
        self._year = None

        self.unsaved_updated_meta = None  # set by self.update_meta()

    def _get_filepath(self, project) -> str:
        _filename = [MetadataStoringsAnalyse._filepath_dict[key]
                     for key in MetadataStoringsAnalyse._filepath_dict.keys()
                     if project.lower() in key.lower()]

        if len(_filename) > 1:
            raise ValueError(f"Found too many files using the given project {project}. \nResults: {_filename} ")

        self.filename = _filename[0]

        # rel_filepath = "data\\metadata\\" + self.filename
        rel_filepath = "data/metadata/" + self.filename

        return rel_filepath

    def _read_json(self) -> json:
        with open(self.filepath, 'r') as json_file:
            _data = json.load(json_file)
        return _data

    def get_all_data(self) -> DataFrame:
        data = pd.json_normalize(data=self._read_json(), max_level=0)
        return data

    def project(self) -> str:
        meta = self.get_all_data()
        return meta["project"][0]

    def startdate(self) -> str:
        meta = self.get_all_data()
        return meta["start_datum"][0].replace('_', '-')

    def contract_info(self) -> dict:
        meta = self.get_all_data()
        return meta["contract_info"][0]

    def meldingen(self) -> dict:
        meta = self.get_all_data()
        return meta["meldingen"][0]

    def storingen(self) -> dict:
        meta = self.get_all_data()
        return meta["storingen"][0]

    def poo_data(self) -> dict:
        meta = self.get_all_data()
        return meta["poo_codes"][0]

    def get_di_dict(self, di: str, notification_type: str = 'meldingen') -> dict:
        """
        Module to filter the dict provided by self.meldingen() or self.storingen() on a specific di number.
        :param notification_type: specification which of the two dict to use. dtype=string
        :param di: number of the deelinstallatie (subsystem). dtype=int or string
        :return: filtered dictionary
        """
        dictionary = self.meldingen() if str(notification_type).lower() in ['m', 'melding', 'meldingen'] \
            else self.storingen() if str(notification_type.lower()) in ['s', 'storing', 'storingen'] \
            else False

        if isinstance(dictionary, bool):
            raise ValueError(f"Incorrect input value given: {notification_type}. Please choose one of the following notification types: 'meldingen', 'storingen'.")

        di_set = {di}  # {di} makes a set of di. set(di) gave different result

        result_dict = {date_key: dictionary[date_key][sub_system]
                       for date_key in dictionary.keys()
                       for sub_system in dictionary[date_key].keys() if sub_system in di_set}

        if result_dict == {}:
            print(f"Can't find sub_system '{di_set}' in the metadata.")

        return result_dict

    @staticmethod
    def _check_first_element(dictionary: dict or list) -> list or np.nan:
        if isinstance(dictionary, dict):
            first_element = [dictionary[key] for key in dictionary.keys()][0]
        elif isinstance(dictionary, list):
            first_element = [dictionary[key] for key in range(len(dictionary))]
        else:
            first_element = np.nan

        return first_element

    def _sum_all_values(self, dictionary: dict) -> int or float:
        """
        Takes a dictionary and sums up all the values found in the dictionary.
        If given a dictionary of dictionaries, it will return the sum of all the values of the underlying
        dictionaries.
        :param dictionary:
        :return:
        """
        first_element = self._check_first_element(dictionary=dictionary)
        if isinstance(first_element, dict):
            return sum([self._sum_all_values(dictionary[key]) for key in dictionary.keys()])

        return sum(dictionary.values())

    def sum_values(self, dictionary: dict, keys: list = None):
        """

        Gedrag nu voor het recursive deel is dat het één getal als antwoord geeft. Misschien is het voor het gebruik
        van de module beter om te stoppen op het hoogste level van keys (stap voordat één antwoord verkregen wordt.
        Dit kan ook een extra feature worden door het optioneel veranderen van een extra parameter.
        :param dictionary:
        :param keys:
        :return:
        """
        if keys is None:
            return self._sum_all_values(dictionary)

        first_element = self._check_first_element(dictionary=dictionary)

        # if first element is int while keys are given
        if isinstance(first_element, int):
            dictionary = {key: dictionary[key] for key in keys}
            return sum([self._sum_all_values(dictionary)])

        # return sum of specific keys from dict
        return sum([self._sum_all_values(dictionary[key]) for key in dictionary.keys() if key in keys])

    def _count_all_values(self, dictionary: dict):
        """
        Takes a dictionary and counts the number of keys found in the dictionary.
        If given a dictionary of dictionaries, it will return number of keys found in the top layer of the
        dictionary.
        :param dictionary:
        :return:
        """
        first_element = self._check_first_element(dictionary=dictionary)

        if isinstance(first_element, dict):
            return len([self._count_all_values(dictionary[key]) for key in dictionary.keys()])

        return len([dictionary[key] for key in dictionary.keys()])

    def count_values(self, dictionary: dict, keys=None):
        if keys is None:
            return self._count_all_values(dictionary)
        # check if keys is a list. If not, change it to list
        keys = [k for k in keys] if not isinstance(keys, list) else keys
        # return sum of specific keys from dict
        return len([self._count_all_values(dictionary[key]) for key in dictionary.keys() if key in keys])

    def avg_monthly(self, dictionary: dict, exclude_keys=None):
        summed_values = self.sum_values(dictionary=dictionary, keys=exclude_keys)
        counted = self.count_values(dictionary=dictionary, keys=exclude_keys)
        return summed_values / counted

    @staticmethod
    def _sort_keys_by_year(dictionary: dict, exclude_year: Union[List[str], str] = None) -> dict:
        """
        Sorts the keys of the given dictionary by years. It returns a new dictionary with setup
        {year: [keys containing year]}
        :param dictionary:
        :param exclude_year:
        :return: dict with build {year: [keys containing year]}
        """
        result_dict = {}
        for datum in dictionary.keys():
            jaar = datum.split('_')[-1]
            if (exclude_year is not None) and jaar in (exclude_year if isinstance(exclude_year, list) else [exclude_year]):
                continue
            else:
                if jaar in result_dict:
                    result_dict[jaar].append(datum)
                else:
                    result_dict[jaar] = [datum]
        return result_dict

    # todo: Onderstaande heeft hetzelfde resultaat als hierboven echter is input dtype anders
    @staticmethod
    def order_month_list_by_year(month_list: list) -> dict:
        """
        Takes a month_list (result from self.get_month_list()) and orders it by year
        :param month_list:
        :return:
        """
        month_list_ordered_by_year = {}

        for month_year in month_list:
            year = month_year.split('_')[-1]
            if year not in month_list_ordered_by_year:
                month_list_ordered_by_year[year] = [month_year]
            else:
                month_list_ordered_by_year[year].append(month_year)

        return month_list_ordered_by_year

    def avg_yearly(self, dictionary: dict, exclude_year: Union[List[str], str] = None) -> float:
        """
        Module calulates the yearly average number of notifications.
        :param dictionary:
        :param exclude_year:
        :return:
        """
        sorted_keys = self._sort_keys_by_year(dictionary=dictionary, exclude_year=exclude_year)
        # Bellow gives a list like [avg_year_1, avg_year_2, ... , avg_year_n]
        notifications_per_year = [self.sum_values(dictionary=dictionary, keys=sorted_keys[year]) for year in sorted_keys.keys()]
        if len(notifications_per_year) == 0:
            return int(0)

        return sum(notifications_per_year) / len(notifications_per_year)

    def _sort_keys_by_quarters(self, dictionary: dict):
        """

        :param dictionary:
        :return:
        """
        result_dict = dict()
        for date in dictionary.keys():
            month, year = date.split('_')
            for quarter in self._quarters.keys():
                key = f'{quarter}_{year}'
                if month in self._quarters[quarter]:
                    if key in result_dict:
                        result_dict[key].append(date)
                    else:
                        result_dict[key] = [date]

        return result_dict

    def avg_quarterly(self, dictionary: dict) -> float:
        # sort dict per quarter
        # notifications_per_quarter like: [q1_year_1, q2_year_1, ..., q4_year_n]
        # return sum() / len()
        sorted_keys = self._sort_keys_by_quarters(dictionary=dictionary)
        # Bellow gives a list like [avg_q_year_1, avg_q2_year_1, ... , avg_q4_year_n]
        notifications_per_q = [self.sum_values(dictionary=dictionary, keys=sorted_keys[q]) for q in sorted_keys.keys()]  # ook te schrijven als keys=[val for val in sorted_keys.values()]
        if len(notifications_per_q) == 0:
            return int(0)
        return sum(notifications_per_q) / len(notifications_per_q)

    # todo: functie omschrijven zodat het werkt via => 'geeft me resultaten van maart' of 'geeft alleen Q4' (van alle jaren)
    def get_month_list(self, notification_type: str = 'melding', exclude_month: Union[List[str], str] = None, exclude_quarter: Union[List[str], str] = None, exclude_year: Union[List[str], str] = None) -> list:
        """
        Returns the list of all the keys that do not contain the specified excluded month or year.
        :param notification_type: specification of the dictionary to get the keys from. default=self.meldingen()
        :param exclude_month: When parsing multiple values, parse them in a list. [excluded_month_1, ... ,excluded_month_n]
        :param exclude_year: same as exclude_month.
        :return:
        """
        dictionary = self.meldingen() if str(notification_type).lower() in ['m', 'melding', 'meldingen'] \
            else self.storingen() if str(notification_type.lower()) in ['s', 'storing', 'storingen'] \
            else False

        if isinstance(dictionary, bool):
            raise ValueError(f"Incorrect input value given: {notification_type}. Please choose one of the following notification types: 'meldingen', 'storingen'.")

        _set_months = set(exclude_month) if exclude_month is not None else set()
        _set_years = set(exclude_year) if exclude_year is not None else set()
        _set_quarter = set(self._quarter_to_month_numbers(exclude_quarter)) if exclude_quarter is not None else set()

        return [key for key in dictionary.keys() if ((key.split('_')[0] not in (_set_months or _set_quarter)) and
                                                     key.split('_')[-1] not in _set_years)]

    def get_keys(self, dictionary: dict,  containing_months: Union[List[str], str] = None, containing_quarter: Union[List[str], str] = None, containing_year: Union[List[str], str] = None) -> list:
        """
        Returns a list of the different keys containing the months, months of a quarter, or the year specified.
        (Note that this module is the complete opposite of self.get_month_list().
        :param dictionary:
        :param containing_months:
        :param containing_quarter:
        :param containing_year:
        :return:
        """
        _set_months = set(containing_months) if containing_months is not None else set()
        _set_years = set(containing_year) if containing_year is not None else set()
        _set_quarter = set(self._quarter_to_month_numbers(containing_quarter)) if containing_quarter is not None else set()

        return [key for key in dictionary.keys() if ((key.split('_')[0] in (_set_months or _set_quarter)) and
                                                     key.split('_')[-1] in _set_years)]

    @staticmethod
    def filter_dictionary_keys(dictionary: dict, keys: List[str]) -> dict:
        """
        Sort of the same functionality as get_month_list, but instead of returning a list with the keynames it returns
        a filtered dictinary.
        :param dictionary:
        :param keys:
        :return:
        """
        keys_to_return = set(keys)
        result = {key: dictionary[key] for key in dictionary.keys() if key in keys_to_return}
        return result

    def _quarter_to_month_numbers(self, quarters: Union[List[str], str]) -> list:
        """
        Returns the corresponding months of the given quarters
        :param quarters:
        :return:
        """
        if isinstance(quarters, str):
            return self._quarters.__getitem__(quarters.capitalize())

        list_to_return = []
        nums = [val for key, val in self._quarters.items() for q in quarters if key == q.capitalize()]
        for n in nums:
            for num in n:
                list_to_return.append(num)

        return list_to_return

    @staticmethod
    def _order_frequency_table(freq_table: dict) -> dict:
        return {key: value for key, value in sorted(freq_table.items(), key=lambda item: item[1], reverse=True)}

    def make_ddict_frequency_table(self, dictionary: Dict[str, dict]) -> dict:
        freq_table = {}
        for ddict in dictionary.values():
            for key, value in ddict.items():
                if key in freq_table:
                    freq_table[key] += value
                else:
                    freq_table[key] = value
        return self._order_frequency_table(freq_table)

    def poo_avg_table(self, poo_dictionary: dict, poo_type: str) -> dict:
        """

        :param poo_dictionary: the full dictionary corresponding to a poo_type in the matadata object
        :param poo_type:
        :return:
        """
        poo_codes = self.return_poo_code_list(poo_type=poo_type)
        sum_per_code = self.make_ddict_frequency_table(dictionary=poo_dictionary)
        avg_table = {key: sum_per_code[key] / len(poo_dictionary) for key in sum_per_code.keys()}
        missing_poo_codes = [code for code in poo_codes if code not in avg_table.keys()]
        if len(missing_poo_codes) > 0:
            for code in missing_poo_codes:
                avg_table[code] = 0
        return self._order_frequency_table(avg_table)

    @staticmethod
    def return_poo_type_string(poo_type: str) -> str:
        # todo: testen of het invloed heeft of de vergelijking gedaan wordt met x '==' y of x 'in' y. 'in' kan
        #  hier voordelig zijn, gezien oplossing soms wordt vermeld als 'oplos'
        if poo_type.lower() == 'probleem':
            poo_string = poo_type.lower() + ' code'
        elif poo_type.lower() == 'oorzaak':
            poo_string = poo_type.lower() + ' code'
        elif poo_type.lower() == 'oplossing':
            poo_string = poo_type.lower() + ' code'
        else:
            raise ValueError("Please parse 'probleem', 'oorzaak' or 'oplossing' as poo_type.")
        return poo_string

    @staticmethod
    def return_poo_code_letter(poo_type: str) -> str:
        if poo_type.lower() == 'probleem':
            code_letter = 'P'
        elif poo_type.lower() == 'oorzaak':
            code_letter = 'C'
        elif poo_type.lower() == 'oplossing':
            code_letter = 'S'
        else:
            raise ValueError("Please parse 'probleem', 'oorzaak' or 'oplossing' as poo_type.")
        return code_letter

    def return_poo_code_list(self, poo_type: str) -> list:
        poo_beschrijvingen = self.contract_info()['POO_codes']
        poo_code_list = [k for k in poo_beschrijvingen.keys() if self.return_poo_code_letter(poo_type) in k or k == 'Leeg']
        return poo_code_list

    def return_ntype_meta_object(self, ntype: str) -> dict:
        if ntype.lower() in 'meldingen':
            meta_data_ntype = self.meldingen().copy()
        elif ntype.lower() in 'storingen':
            meta_data_ntype = self.storingen().copy()
        else:
            raise ValueError("Please parse 'meldingen' or 'storingen' as ntype.")
        return meta_data_ntype

    def update_poo_data(self, staging_file_data: DataFrame) -> dict:
        poo_data_meta = self.poo_data().copy()
        for poo in poo_data_meta.keys():
            # Exception in workflow for oplos code -> an definitive solution is needed when generating the staging file
            col2read = self.return_poo_type_string(poo)
            value_count = staging_file_data[col2read].value_counts(dropna=False).to_dict()
            if np.nan in value_count:
                value_count["Leeg"] = value_count[np.nan]
                del value_count[np.nan]
            else:
                value_count["Leeg"] = 0

            key = str(self._quarter) + '_' + str(self._year)
            new_poo_type_data = {key: value_count}

            poo_data_meta[poo] = dict(**poo_data_meta[poo], **new_poo_type_data)

        return poo_data_meta

    def update_ntype_data(self, staging_file_data: DataFrame, ntype: str) -> dict:
        meta_ntype_data = self.return_ntype_meta_object(ntype=ntype)  # returns self.meldingen() or self.storingen()
        # todo: col_name bellow is too hard coded in script. make more abstract
        staging_file_ntype_data = staging_file_data[staging_file_data['type melding (Storing/Incident/Preventief/Onterecht)'] == ntype.title()] \
            if ntype.lower() in 'storingen' else staging_file_data

        sf_ntype_data_grouped = staging_file_ntype_data.groupby(['month_number'])
        new_ntype_data = dict()
        for group in sf_ntype_data_grouped.groups:

            group_df = sf_ntype_data_grouped.get_group(group)
            value_count = group_df['sbs'].value_counts().to_dict()
            # int(str(group)) because notification 'Expected type 'int', got 'Hashable' instead'
            # print(f'group var is type {type(group)}') gives 'type == int' though
            key = '0' + str(group) + '_' + str(self._year) if int(str(group)) < 10 else str(group) + '_' + str(self._year)
            new_ntype_data[key] = value_count

        # Adding new data at the end of existing data
        updated_meta_ntype_data = dict(**meta_ntype_data, **new_ntype_data)
        return updated_meta_ntype_data

    def update_meta(self, staging_file_data: DataFrame) -> None:
        # updating poo_codes
        updated_poo_data = self.update_poo_data(staging_file_data=staging_file_data)
        # update meldingen
        updated_meldingen = self.update_ntype_data(staging_file_data=staging_file_data, ntype='meldingen')
        # update storingen
        updated_storingen = self.update_ntype_data(staging_file_data=staging_file_data, ntype='storingen')
        self.unsaved_updated_meta = {"project": self.project(),
                                     "start_datum": self.startdate(),
                                     "contract_info": self.contract_info(),
                                     "poo_codes": updated_poo_data,
                                     "meldingen": updated_meldingen,
                                     "storingen": updated_storingen}

    # todo: module voor opslaan metadata
    # todo: toevoegen aan documentatie
    def save_meta(self):
        pass


if __name__ == '__main__':
    import os
    os.chdir('..\\rapport generator')

    project = 'coentunnel'
    metadata = MetadataStoringsAnalyse(project)

    meldingen = metadata.meldingen()
    storingen = metadata.storingen()

    m = metadata.sum_values(meldingen)
    s = metadata.sum_values(storingen)  # sum of all values found in the dicts of dicts

    data2019 = [key for key in storingen.keys() if '2019' in key]
    oktober = [key for key in meldingen.keys() if "10" in key[:3]]

    aantal_storingen_2019 = metadata.sum_values(dictionary=storingen, keys=data2019)  # 166
    aantal_meldingen_maart_2018 = metadata.sum_values(dictionary=meldingen, keys=['03_2018'])  # 27
    lijst_meldingen_oktober = [metadata.sum_values(dictionary=meldingen, keys=key) for key in oktober]

    meling_ = metadata.count_values(dictionary=meldingen, keys='03_2018')
    storingen_2019 = metadata.count_values(dictionary=storingen, keys=data2019)

    avg_oktober = metadata.avg_monthly(dictionary=meldingen, exclude_keys=oktober)
    avg_2019 = metadata.avg_monthly(dictionary=storingen, exclude_keys=data2019)

    data_61_mod = metadata.get_di_dict(notification_type='meldingen', di='61')

    avg_mod = metadata.avg_yearly(dictionary=meldingen, exclude_year=['2020'])

    maand_lijst = metadata.get_month_list(exclude_month=['02'], exclude_year=['2019'])

    meldingen_per_di_avg = metadata.avg_yearly(dictionary=metadata.get_di_dict(di='46A-08'), exclude_year='2020')

    months_to_exclude = [metadata._quarters[q][i] for q in metadata._quarters.keys() if q != 'Q1' for i in
                         range(len(metadata._quarters[q]))]
    month_list = metadata.get_month_list(exclude_month=months_to_exclude)

    kwartaal_lijst=['q1', 'q3']
    mmlijst = metadata._quarter_to_month_numbers(quarters=kwartaal_lijst)
    test_q_m_list = metadata.get_month_list(exclude_quarter='q3')
    sort_by_q = metadata._sort_keys_by_quarters(dictionary=metadata.meldingen())
    avg_q = metadata.avg_quarterly(dictionary=metadata.meldingen())

    poo = metadata.poo_data()['probleem']
    print([metadata.sum_values(dictionary=poo[_], keys=['P05']) for _ in poo.keys()])

    x = metadata.unsaved_updated_meta
